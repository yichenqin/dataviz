--- 
title: "Ch7P2 Visualization Types - Part II"
subtitle: "Descriptive Analytics and Data Visualization"
author: "Yichen Qin (qinyn@ucmail.uc.edu), University of Cincinnati"
date: "`r Sys.Date()`"
output: 
  html_document:
    number_sections: true
    code_folding: "show"
    toc: true
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
---

# Visualization Types - Part II {-}

In this chapter, we continue to discuss the commonly used visualization types.
The following R packages are required to run the examples in this chapter.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggforce)
library(readxl)
library(sunburstR)
library(RColorBrewer)
library(grid)
library(gridExtra)
library(graphics)
library(vcd)
library(ggrepel)
library(ggsci)
library(ggtern)
library(sqldf)
library(waterfalls)
```


# Visualization of Association for Discrete Data

## Mosaic Plot

A mosaic plot (also known as a Marimekko diagram) is a graphical method for visualizing data from two or more qualitative variables. It is the multidimensional extension of spineplots, which graphically display the same information for only one variable. It gives an overview of the data and makes it possible to recognize relationships between different variables. 

Dataset

We are using the Titanic dataset from the ggplot2. This dataset provides the information about the passengers who died on the Titanic's maiden voyage with economic status (class), gender, age and survival status.


Package

There are many choices in R to draw mosaic plot. We can use geom_rect() in ggplot2 or geom_mosaic() in ggmosaic or mosaicplot() in graphics or mosaic() in vcd. 

```{r}
library(tidyverse)
library(graphics)
library(vcd)
```

Example by using graphics package

```{r}
titanic=read.csv("data/titanic.csv")
dim(titanic)
titanic[seq(1,dim(titanic)[1],by=50),]
titanic_tab=table(titanic)
titanic_tab
mosaicplot(~ Class + Sex , data = titanic, 
           main = "Survival on the Titanic", color = TRUE)
mosaicplot(~ Class + Sex + Age , data = titanic, 
           main = "Survival on the Titanic", color = TRUE)
mosaicplot(~ Class + Sex + Age + Survived, data = titanic, 
           main = "Survival on the Titanic", color = TRUE)
#mosaicplot(~ Class + Sex + Survived, data = titanic)
#mosaicplot(~ Sex + Class + Survived, data = titanic)
```

Another package for mosaic plots.

```{r}
#vcd package
#data("Titanic")
#head(Titanic) # the same as titanic_tab
#mosaic(Titanic) 
mosaic(~ Sex + Age + Survived + Class, data = titanic,
  main = "Survival on the Titanic", shade = TRUE, legend = TRUE)
#assoc(Titanic, shade=TRUE, legend=TRUE)
```

In this incident, people tended to protect women and children. Adult men sacrificed themselves to give children and women opportunities, and the crew sacrificed themselves to give higher-class people opportunities.

Another example by using `vcd` package.

```{r, eval=FALSE}
data001 <-read.csv("data/cinema.csv")
mosaicplot(~ year + release_date,  data =data001, 
           shade = T, color = T, main ="cinema" ) +
  theme(axis.text.x=element_text(angle=-45, hjust= .1))
```


## Parallel Sets

A parallel sets plot is a new method for the visualization and interactive exploration of categorical data that shows data frequencies instead of the individual data points. 
The method is based on the axis layout of parallel coordinates, with boxes representing the categories and parallelograms between the axes showing the relations between categories.

We are using the Titanic data set from the ggplot2. 
This data set provides the information about the passengers on the Titanic's maiden voyage, including their ticket class (economic status), gender, age, and survival status.
Note that we have to reorganize the data set before using the parallel sets plot.
```{r, fig.width=10}
library(ggforce) # Package
titanic_tab=table(titanic)
titanic_tab
titanic_freq <- reshape2::melt(titanic_tab)
titanic_freq

parallel_data14 <- gather_set_data(titanic_freq, c(1,4))
parallel_data14
g1=ggplot(parallel_data14, aes(x=factor(x, levels = c("Class", "Sex","Age","Survived")), id = id, split = y, value = value)) +
  xlab("Covariates")+
  geom_parallel_sets(aes(fill = Survived),alpha = 0.3, axis.width = 0.2) +
  geom_parallel_sets_axes(axis.width = 0.2) +
  geom_parallel_sets_labels(color = 'white',size=3)
parallel_data124 <- gather_set_data(titanic_freq, c(1,2,4))
parallel_data124
g2=ggplot(parallel_data124, aes(x=factor(x, levels = c("Class", "Sex","Age","Survived")), id = id, split = y, value = value)) +
  xlab("Covariates") +
  geom_parallel_sets(aes(fill = Survived), alpha = 0.3, axis.width = 0.2) +
  geom_parallel_sets_axes(axis.width = 0.2) +
  geom_parallel_sets_labels(colour = 'white',size=3)
#grid.arrange(g1,g2,ncol=2)

data <- reshape2::melt(Titanic)
data <- gather_set_data(data, 1:4)

ggplot(data, aes(x, id = id, split = y, value = value)) +
  geom_parallel_sets(aes(fill = Sex), alpha = 0.3, axis.width = 0.1) +
  geom_parallel_sets_axes(axis.width = 0.1) +
  geom_parallel_sets_labels(colour = 'white')
```

```{r, fig.width=10}
parallel_data1234 <- gather_set_data(titanic_freq, c(1,2,3,4))
parallel_data1234
g3=ggplot(parallel_data1234, aes(x=factor(x, levels = c("Class", "Sex","Age","Survived")), id = id, split = y, value = value)) +
  xlab("Covariates")+
  geom_parallel_sets(aes(fill = Survived), alpha = 0.3, axis.width = 0.2) +
  geom_parallel_sets_axes(axis.width = 0.2) +
  geom_parallel_sets_labels(color = 'white',size=3)
parallel_data123 <- gather_set_data(titanic_freq, c(1,2,3))
parallel_data123
g4=ggplot(parallel_data123, aes(x=factor(x, levels = c("Class", "Sex","Age","Survived")), id = id, split = y, value = value)) +
  xlab("Covariates") +
  geom_parallel_sets(aes(fill = Survived), alpha = 0.3, axis.width = 0.2) +
  geom_parallel_sets_axes(axis.width = 0.2) +
  geom_parallel_sets_labels(colour = 'white',size=3)
grid.arrange(g3,g4,ncol=2)

```
Note that the data is now organized in a way that can be directly plot.
The last four columns are the most important part.
Note there are 32 different groups of passengers, i.e., 32 group = 4 class * 2 genders * 2 ages * 2 survival status.
Therefore, the variable id marks these 32 groups.
For each group, the variable value stores how many passengers in this group.
The variables x and y indicates the group label, i.e., whether is a male group or female group, child group or adult group.
This whole process is repeated four times because we have in total four categorical variables.

The figure above describes the data and the number of passengers in each category.
In addition, it displays how two category variables interact with each other.
For example, age and class, class and gender, and gender and survival.

However, what if we want to see how survival interacts with all other variables?
Since the survival status is the most important variable, we can move it to another dimension, the color of the bands.
```{r}
```

# Visualization of Composition

## Tree Map

Treemaps display hierarchical (tree-structured) data as a set of nested rectangles. Each branch of the tree is given a rectangle, which is then tiled with smaller rectangles representing subbranches. A leaf node's rectangle has an area proportional to a specified dimension of the data.Often the leaf nodes are colored to show a separate dimension of the data.

Dataset: We are using the data set about Indonesia's mobile phone market sales in the first half of 2020. The data is available at: https://www.kaggle.com/kurniakh/marketplace-data

```{r}
phone<-read.csv("data/phone.csv")
dim(phone)
phone[seq(1,nrow(phone),by=10),]
```


Package

```{r}
library(tidyverse)
library(treemapify)
```
Tree map

```{r, fig.height=10, fig.width=10}
ggplot(phone, 
       aes(area = sold,
           subgroup = region,
           subgroup2 = brand,
           subgroup3 = type,
           fill=lnrmb))+
  geom_treemap()+
  geom_treemap_subgroup3_border(color="white",size=1)+
  geom_treemap_subgroup2_border(color="red",size=2)+
  geom_treemap_subgroup_border(color="blue",size=3)+
  #geom_treemap_subgroup_text(place = "centre", grow = TRUE, alpha = 0.5, colour ="white")+
  geom_treemap_subgroup2_text(place = "bottom", grow = TRUE, alpha = 0.3, colour ="red")+
  geom_treemap_text(aes(label=type),colour = "white", place = "topleft", reflow = TRUE, size=10)+
  scale_fill_distiller(palette="Blues",name="phone\nprice\n(RMB)", breaks = log(c(250, 500, 1000, 2000, 4000, 8000, 16000)), labels = c(250, 500, 1000, 2000, 4000, 8000, 16000))
```



area=sold，the area is the sales volume of the mobile phone.

fill=lnrmb，the shade of the color represents the price (the price takes the logarithm ) of the phone. The cheaper price, the darker color.

subgroup=region，According to the origin of mobile phone brands, it is divided into two types: China (left of the black line) and not-China. As we can be seen from the figure, the Indonesian mobile phone market does not have local brands. Most of them are Chinese brands.

subgroup2=brand, Chinese brands include Xiaomi, oppo, vivo, realme, etc., and non-Chinese brands include Apple, Samsung and Nokia.

subgroup3=type, based on the type of phone models, the most popular models in Indonesia are mainly cheaper models.

We can use tree map to visualize the titanic data set, however, it is less efficient than mosaic plot.

```{r, eval=FALSE}
titanic_df=as.data.frame(table(titanic[,c("Class","Sex","Survived")]))
ggplot(titanic_df, 
       aes(area = Freq,
           subgroup = Class,
           subgroup2 = Sex,
           subgroup3 = Survived,
           label=paste("Class",Class,Sex,"Survived",Survived)))+
  geom_treemap()+
  geom_treemap_subgroup3_border(color="yellow",size=1)+
  geom_treemap_subgroup2_border(color="red",size=3)+
  geom_treemap_subgroup_border(color="blue",size=5)+
  geom_treemap_subgroup_text(place = "centre", grow = TRUE, alpha = 0.2, colour ="blue",fontface = "bold")+
  geom_treemap_subgroup2_text(place = "bottom", grow = FALSE, alpha = 0.2, colour ="red",fontface = "italic")+
  #geom_treemap_subgroup3_text(place = "top", grow = FALSE, alpha = 0.2, colour ="white",fontface = "italic")+
  geom_treemap_text(colour = "yellow", place = "topleft", reflow = FALSE,size=10)
# alternatively
titanic_df2=as.data.frame(table(titanic))
ggplot(titanic_df2, 
       aes(area = Freq,
           subgroup = Class,
           subgroup2 = Sex,
           subgroup3 = Age,
           subgroup4 = Survived,
           label=paste("Class",Class,Sex,Age,"Survived",Survived)))+
  geom_treemap()+
  geom_treemap_subgroup3_border(color="yellow",size=1)+
  geom_treemap_subgroup2_border(color="red",size=3)+
  geom_treemap_subgroup_border(color="blue",size=5)+
  geom_treemap_subgroup_text(place = "centre", grow = TRUE, alpha = 0.2, colour ="blue",fontface = "bold")+
  geom_treemap_subgroup2_text(place = "bottom", grow = FALSE, alpha = 0.2, colour ="red",fontface = "italic")+
  geom_treemap_subgroup3_text(place = "left", grow = FALSE, alpha = 0.2, colour ="yellow",fontface = "italic",size=20)+
  geom_treemap_text(colour = "white", place = "topleft", reflow = FALSE,size=10)
```



## Sunburst Chart

A sunburst chart is typically used to visualize hierarchical data structures.
A sunburst chart is also called wedge stack graph, radial hierarchy, circular bar plot, ring chart, multi-level pie chart, and radial treemap.
The sunburst chart consists of an inner circle surrounded by rings of deeper hierarchy levels. 
The angle of each segment is either proportional to a value or divided equally under its parent node.
All segments in sunburst charts may be colored according to which category or hierarchy level they belong to.

```{r warning=FALSE}
library(tidyverse)
library(readxl)
library(sunburstR)
library(RColorBrewer)
```

Data set: We visualize the data set on Indonesia's mobile phone market sales in the first half of 2020 (https://www.kaggle.com/kurniakh/marketplace-data).
```{r}
phone=read.csv("data/phone_sunburst.csv",header = TRUE)
phone_sun=phone[,c("PhoneModel","BrandCountry","Brand","Sold")]
phone_sun$Category=paste(phone$BrandCountry,phone$Brand,phone$PhoneModel,sep="-")
phone_sun=phone_sun[,c("Category","Sold")]
sund2b(phone_sun,
       color=colorRampPalette(brewer.pal(11,"Set3"))(35),              #add new colors
         showLabels = FALSE, 
         rootLabel = "Total Phone Sold in Indonesia 2020")
```

## Ternary Plot

A ternary plot, ternary graph, triangle plot, simplex plot, Gibbs triangle or de Finetti diagram is a barycentric plot on three variables which sum to a constant. It graphically depicts the ratios of the three variables as positions in an equilateral triangle. It is used in physical chemistry, petrology, mineralogy, metallurgy, and other physical sciences to show the compositions of systems composed of three species. In population genetics, it is often called a de Finetti diagram. In game theory, it is often called a simplex plot. Ternary plots are tools for analyzing compositional data in the three-dimensional case.

```{r, warning=FALSE, message=FALSE}
library(ggtern)
```

We now use a simple example generating from uniform distribution U(0,1) to show a ternary plot

```{r}
df=data.frame(prop1=0.1,prop2=0.3,prop3=0.6)
df2=data.frame(prop1=0.05,prop2=0.03,prop3=0.92)
df=rbind(df,df2)
g1=ggtern(data=df,mapping=aes(x=prop1,y=prop2,z=prop3))+
  geom_point(size=2)+
  geom_Tline(Tintercept=c(0.3))+
  geom_Lline(Lintercept=c(0.1))+
  geom_Rline(Rintercept=c(0.6))
g1
```

USDA textural classification chart

We are using the "USDA" data set from package ggtern which is issued by the United States Department of Agriculture (USDA) in the form of a ternary diagram.

```{r}
data("USDA", package = "ggtern")
dfLabels <- plyr::ddply(USDA, "Label", function(df) {
   label <- as.character(df$Label[ 1 ])
  df$Angle <- switch(label, "Loamy Sand" = -35, 0)
  colMeans(df[setdiff(colnames(df), "Label")])
   })
f5a<-ggtern(data = USDA, mapping = aes(x = Sand, y = Clay, z = Silt))+ #three axes for Sand、Clay、Silt
  geom_polygon(mapping = aes(fill = Label),
                 alpha = 0.75, size = 0.5, color = "black")+ #add polygons，set the fill color based on Label，transparency as 0.75，size as 0.5，the color of the edge is black
  geom_text(data = dfLabels, mapping = aes(label = Label, angle = Angle),
              size = 2.5) +#add text which contains dfLabels's Label，Angle as tne angle
     theme_rgbw() + #R default background
     theme_showsecondary() +#R default background with Scale
     theme_showarrows() +
     custom_percent("Percent") +#add'percent'
     guides(color = "none", fill = "none")+ 
  labs(title = "USDA Textural Classification Chart",#title it。。。
          fill = "Textural Class", #the name of color for filling
       color = "Textural Class")# the name of color for edges
print(f5a)
```


## Pie Chart

We can use the functions in ggplot2 package to draw pie chart. 
We are using the "content_rating" in the dataset of American movies.
This variable is about film ratings.

```{r}
library(ggsci)
cinema=read.csv("data/cinema.csv",header = T)
df <- as.data.frame(table(cinema$content_rating))
df # Generating the table of content_rating
df = df[order(df$Freq, decreasing = TRUE),]   ## order the Freq variable in the dataset
Label = as.vector(df$Var1)
Label = paste(Label, "(", round(df$Freq / sum(df$Freq) * 100, 2), "%)        ", sep = "")   
df = df[order(df$Freq, decreasing = TRUE),]  
g1=ggplot(df, aes(x="", y=reorder(Var1,Freq), fill=Var1)) +
  geom_bar(stat="identity",width=1) + 
  coord_polar("y")+  
  labs(x = "", y = "", title = "") +  
  scale_fill_lancet()+ 
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right")+ 
  geom_text(aes(label = Label), position = position_stack(vjust = 0.5)) + #Add percentage
  ggtitle("IMDB MPAA Rating")
g2=ggplot(df,aes(x=Var1,y=Freq, fill=Var1))+
  geom_bar(stat="identity",width = 0.8)+
  scale_fill_lancet()
grid.arrange(g1,g2,ncol=2,widths = c(2, 1))
```



## Donut Chart

```{r, warning=FALSE, message=FALSE}
library(sqldf)
```

**Single Donut Chart**

We use geom_rect() function from ggplot2 package to draw the plot as rectangle then the coord_polar(theta="y") can transfer the plot to circle. 
And we can control the size of the circle by adjusting the x-axis.

The data set we use is the information of American universities.

```{r}
m<-read.csv("data/college.csv")
summary(m[,c(5:8)])
```


```{r}
data1<-data.frame(category=c("Associate","Bachelor","Graduate"),#build the data frame
                  count=c(20,200,1049))
data1$fraction = data1$count / sum(data1$count)#calculate the percentage
data1$ymax = cumsum(data1$fraction)
data1$ymin = c(0, head(data1$ymax, n=-1))
data1$labelPosition <- (data1$ymax + data1$ymin) / 2 #position of the label 
data1$label <- paste0(data1$category, "\n ", data1$count,"\n","(",round(data1$fraction*100,1),"%)")
ggplot(data1, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=category)) +
  geom_rect() + #draw the plot as rectangle
  geom_text( x=1.8, aes(y=labelPosition, label=label, color=category), size=3.5) +
  scale_fill_brewer(palette=10) +#color of fillment
  scale_color_brewer(palette=5) +#color of title
  coord_polar(theta="y") +#change to circle
  xlim(c(-1, 4)) +#cut the center of the circle
  labs(title = "Distribution of the highest degree in universities (The count and percentage)")+
  theme_void() +
  theme(legend.position = "none")
```

**Multiple Donut Chart**

Now we want to show the distribution of private and public universities in different areas.

```{r}
data2<-sqldf("select region,control,count(control) as control_count from m group by region,control")
data3<-sqldf("select region,count(control) as control_sum from m group by region")
data4<-merge(data2,data3,by= "region")
data4$control_percent<-data4$control_count/data4$control_sum
data4$label1<-c("Midwest"," ","Northeast"," ","South"," ","West"," ")
data4$label2<-paste(data4$control,":\n",data4$control_count,"\n(",round(data4$control_percent*100,1),"%)")
```

Show the data frame

```{r}
head(data4)
```



```{r}
ggplot(data4, aes(x = region, y = control_percent, fill = control)) +
  geom_col() + # 
  geom_text(aes(label=label2),size=2.2,position=position_stack(vjust = 0.5))+
  geom_text(aes(label=label1),size=5,position = position_fill())+
  scale_x_discrete(limits = c(" "," "," ", "Midwest","Northeast","South","West")) +  #cut the center of the circle
  scale_fill_brewer(palette=3) +
  coord_polar("y")+                                                                  #change to circle
  labs(title = "Distribution of Private and Public Universities")+
  theme_void()+
  theme(legend.position = "none")
```

# Visualization of Change

## Slope Graph

A slope graph is a lot like a line graph, but it plots only the change between two time points, without any regard for the points in between.
It is based on the idea that humans are good at interpreting changes in directions, i.e., slopes.

Package

```{r}
library(tidyverse)
library(ggrepel)
library(RColorBrewer)
```

We are using the data set from the Fortune magazine, which describes the change of Revenue of top 10 Fortune 500 companies in 2018 and 2019.

```{r}
df <- read.csv("data/top10.csv",header = T)
Name <- factor(df$Name)
df$Revenue <- df$Revenue/1000
```

```{r}
q <- ggplot(df,
            aes(x = Year,
                y = Revenue,
                color = Name,
                group = Name)) +  
  geom_line(size=1) +
  geom_point(size=2) + 
  scale_x_continuous(breaks = c(2018, 2019),
                     labels = c(2018, 2019),
                     position = "top") +
 labs(title= "Revenue of the world's top 10 companies\n(in Million Dollars)") +
  theme(aspect.ratio = 2)
q
```

We add the text to the slopes.

```{r}
q <- ggplot(df,
            aes(x=Year,
                y=Revenue,
                group=Name,
                color=Name)) +  
  geom_line(size=1) +
  geom_point(size=2) +
  labs(title= "2018-2019 Revenue of\nworld's top 10 companies",
       subtitle="(in Billions)") +
  scale_x_continuous(name = "",
                     position = "top",
                     breaks = c(2018, 2019),
                     labels = c("2018", "2019"),
                     limits = c(2018, 2022)) +
  scale_y_continuous(breaks = seq(200, 600, 100),
                     labels = format(seq(200, 600, 100), scientific = FALSE),
                     limits = c(200, 600)) +
  theme(legend.position = "none",
        aspect.ratio = 1.25,
        panel.background = element_rect(fill = "white")) +
  geom_text_repel(data = df %>% filter(Year == "2019"), 
                  aes(label = Name) , 
                  hjust = "left", 
                  fontface = "bold", 
                  size = 2.5, 
                  nudge_x = 0.3, 
                  direction = "y") +
   scale_color_viridis_d()
q 
```

## Arrow Plot

[New York Times' "Where the 1 Percent Have Gained the Most"](https://www.nytimes.com/2017/11/17/upshot/income-inequality-united-states.html)

```{r}
df %>% 
  mutate(Name = fct_reorder(Name, Revenue, min)) %>%
  arrange(Year) %>%
  ggplot() +
  geom_path(aes(x = Revenue, y = Name),
            arrow = arrow(length=unit(0.2,"cm"), type = "closed")) +
  geom_text(aes(x = Revenue, y = Name, label = round(Revenue),
                hjust = ifelse(Year == 2018, 1.4, -0.4))) +
  geom_text(data = df %>% group_by(Name) %>% summarize(ave_Revenue = mean(Revenue)),
            aes(x = ave_Revenue, y = Name, label = Name),
            vjust = 2,
            size = 2) +
  coord_cartesian(xlim = c(200, 600)) +
  scale_x_continuous(breaks = seq(200, 600, 100),
                     labels = format(seq(200, 600, 100), scientific = FALSE))
```


## Nightingale Rose Chart/Radial Column Chart/Radial Barplot

In 1858 nurse, statistician, and reformer Florence NightingaleOffsite Link published Notes on Matters Affecting the Health, Efficiency, and Hospital Administration of the British Army. Founded Chiefly on the Experience of the Late War. Presented by Request to the Secretary of State for War. This privately printed work contained a color statistical graphic entitled "Diagram of the Causes of Mortality in the Army of the EastOffsite Link" which showed that epidemic disease, which was responsible for more British deaths in the course of the Crimean War than battlefield wounds, could be controlled by a variety of factors including nutrition, ventilation, and shelter. The graphic, which Nightingale used as a way to explain complex statistics simply, clearly, and persuasively, has become known as Nightingale's Rose chart.

```{r, echo=FALSE}
Nightingale=read.csv("data/Nightingale.csv",header = TRUE)
data = Nightingale %>% 
  select(Date, Month, Year, contains("rate")) %>% 
  pivot_longer(cols = 4:6, names_to = "Cause", values_to = "Rate") %>% 
  mutate(Cause = gsub(".rate", "", Cause),
         period = ifelse(Date <= as.Date("1855-03-01"), "April 1854 to March 1855", "April 1855 to March 1856"),
         Month = fct_relevel(Month, "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "Jan", "Feb", "Mar", "Apr", "May", "Jun"))
ggplot(data, aes(Month, Rate)) + 
  geom_col(aes(fill = Cause), width = 1, position = "identity") + 
  coord_polar() + 
  facet_wrap(~period) +
  scale_fill_manual(values = c("skyblue3", "grey30", "firebrick")) +
  scale_y_sqrt() +
  theme_void() +
  theme(axis.text.x = element_text(size = 9),
        strip.text = element_text(size = 11),
        legend.position = "bottom",
        plot.background = element_rect(fill = alpha("cornsilk", 0.5)),
        plot.margin = unit(c(10, 10, 10, 10), "pt"),
        plot.title = element_text(vjust = 5)) +
  ggtitle("Diagram of the Causes of Mortality in the Army in the East")
```


Dataset

<!---
We are using the dataset of top 20 channel from Bilibili.com.
```{r}
bl=read.csv( "data/bilibili.csv",header = T)
channel <- factor(bl$channel)
bl
```

Draw the plot

```{r}
q=ggplot(bl, aes(channel, subscribers,fill = subscribers)) +  
  geom_col(width = 1, color = 'white') +  #Draw the rectangle first 
  scale_fill_gradientn(colors = c("blue","#66FF00","#FFFF00","#FF9900","#FF3300","#CC0000")) + #choose color to fill
 coord_polar(direction=-1)  # Transfer to polar coordinate system
q
```

Order the plot

```{r}
p=ggplot(bl, aes(x=reorder(channel, subscribers), y=subscribers,fill = subscribers)) +  #order the channel
  geom_col(width = 1, color = 'white') + 
  scale_fill_gradientn(colors = c("blue","#66FF00","#FFFF00","#FF9900","#FF3300","#CC0000")) + 
 coord_polar(direction=-1)
p
```

Improvement

```{r}
p+theme_bw()+   #change the background to white
 theme(
 panel.grid = element_blank(),
 panel.border= element_blank(),
 axis.text.y = element_blank(),
 axis.text.x = element_blank(),
 axis.ticks = element_blank(),
axis.title = element_blank()  #clear the label and grid
    )+
ylim(-500,1450)+   # ylim to change the range of y
guides(fill=F)+  
annotate("text", x=0,y=-500,label="bilibili \n subscribers \n Top 20", fontface="bold",colour="steelblue",size=4) + # in the center of the plot
geom_text(aes(label = paste(channel, subscribers,  'K')),color = "dark blue",vjust = "left", hjust = "outward",fontface="bold",  size = 3)            #add note to the plot
```

--->

Period time

We can use the circle in the Nightingale's rose chart to represent a period time. 
The data set we used is the number of airport passengers in Taiwan for each month in 2018.

```{r}
tw=read.csv("data/taiwanairport2018.csv",header = T)
month <- factor(tw$month)
twrose=ggplot(tw, aes(x=reorder(month, monthnum), y=passengers,fill = passengers)) +  
  geom_col(width = 1, color = 'white') +  
  scale_fill_gradientn(colors = c("yellow","orange","red")) +
  coord_polar()  +
  theme_bw()+  
  theme(
    panel.grid = element_blank(),
    panel.border= element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank() 
  )   +
  labs(
    title= "The number of passengers in Taiwan's airport for each month in 2018"
  )+
  guides(fill=F)+  
 geom_text(aes(label = paste(month, passengers)),color = "dark blue",vjust = "left", hjust = "outward",fontface="bold",  size = 3.5)
twrose
```


A Radial column Chart is simply a Bar Chart plotted on a polar coordinate system, rather than on a Cartesian one.

Package
```{r}
library(tidyverse)
library(ggthemes)
```

Dataset

We are using the 2015.csv which is about the number of cardiovascular patient in Guilin city of 2015

```{r}
gui<-read.csv("data/2015.csv")
data1<-aggregate(gui[,(12:14)],list(gui$month),sum)
data1<-data1 %>% gather("gender","value",-c(1,2)) 
head(data1)
```

Draw the Radial Column Chart

```{r}
ggplot(data1,aes(as.factor(Group.1),value,fill=as.factor(gender)))+
  geom_col(color="black",position=position_dodge(),width=0.5,size=0.25)+  # draw the bar plot
  coord_polar()+                                                             #change to polar system
  scale_x_discrete(limits = c(as.factor(1:12)), # the range of x
                   labels=c("Jan.","Feb.","Mar.","Apr.","May","Jun.",    # label of x
                            "Jul.","Aug.","Sep.","Oct.","Nov","Dec.")) +
  #scale_y_continuous(breaks=c(-800,0,500,1000,1500,2000),labels=c("","0","500","1000","1500","2000"))+ 
  ylim(c(-800,2000))+                                                        #the range of y
  geom_segment(aes(x=1,y=0,xend=12,yend=0),colour="black")+
  guides(fill=guide_legend(title = NULL)) +          #delete the title
  labs(title = "The number of cardiovascular patients in Guilin city of 2015")+   #add new title
  scale_fill_discrete(labels=c("Female","Male"))+  
  theme(axis.text.x = element_text(size = 10),      
        axis.title = element_blank(),              
        axis.line = element_blank(),                
        legend.text = element_text(size = 8),       #addjust the size of the text 
        legend.key.size = unit(3.6,'mm'),           #addjust the size of the plot 
        legend.position = c(0.5,0.5),               #addjust the position of plot
        plot.title = element_text(size = 12.5),     #addjust size of text of title
        #panel.grid.major.y = element_blank(),       #add grid in y-axis
        panel.grid.major.x = element_line(size = 0.7,linetype = "dotted")
        )
```



# Others

## Cleveland Dot Plot/Lollipop Chart

A Cleveland dot plot proposed by William S. Cleveland and Robert McGill (https://www.jstor.org/stable/2288400) is a great alternative to a simple bar chart, particularly if you have more than a few items, in which case a bar chart can easily look cluttered.
In the same amount of space, many more values can be included in the Cleveland dot plot, and it is easy to read as well.
A Cleveland dot plot typically plots a categorical variable against a numeric variable. 

Note that even though the bar plot can visualize whatever the Cleveland dot plot visualizes, the bar plot often costs more data-ink compared to the Cleveland dot plot.
Often times, the Cleveland dot plot can be more efficient.


```{r}
mtcars_revised <- mtcars %>% 
                  arrange(mpg) %>% 
                  mutate(name = row.names(mtcars)) %>%
                  mutate(name = factor(name, levels = .$name))
ggplot(mtcars_revised, aes(x = mpg, y = reorder(name,-mpg), label = mpg) ) +
  geom_point() +
  theme_bw() +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_line(colour = "grey60", linetype = "dashed")
  )
```

A lollipop chart is a simple modification of the Cleveland dot plot. 
In addition to the dots, a lollipop chart contains lines that tie each categories to their relative dot, forming lollipops.
A lollipop chart is great for comparing multiple categories as it aids the reader in aligning categories to points but minimizes the amount of ink on the graphic.

```{r}
ggplot(mtcars_revised, aes(x = mpg, y = reorder(name,-mpg), label = mpg) ) +
  geom_point() +
  geom_text(nudge_x = 1.5) +
  geom_segment(aes(x = 0, xend = mpg, 
                   y = name, yend = name), color = "grey50") +
  theme_bw()
```

There are many extensions of the Cleveland dot plot and the lollipop chart.
```{r, eval=FALSE}
mpg_revised <- mpg %>% mutate(brandmodel=paste(manufacturer, model)) %>%
                  group_by(brandmodel) %>% 
                  summarize(avg_hwy=mean(hwy, na.rm=TRUE),
                            avg_cty=mean(cty, na.rm=TRUE))
ggplot(mpg_revised) +
  geom_point(aes(avg_hwy, brandmodel),col="blue") +
  geom_point(aes(avg_cty, brandmodel),col="red") +
  geom_segment(aes(x = avg_cty, xend = avg_hwy, 
                   y = brandmodel, yend = brandmodel), color = "grey50")+
  geom_text(aes(x = avg_cty, y=brandmodel, label = round(avg_cty, 1)), size = 3, hjust = 1.5) +
  geom_text(aes(x = avg_hwy, y=brandmodel, label = round(avg_hwy, 1)), size = 3, hjust = -.5)
```


## Waterfall Plot

The waterfalls package is based on ggplot2. We are going to use the function waterfall in the package to draw the plot.

We are using the dataset miga.csv which provides summary income statement from quarterly statements.

Data resource: MIGA Summary Income Statement From World Bank Financial Open Data

```{r}
library(waterfalls)
```


```{r}
miga<-read.csv("data/miga.csv")
miga$Item<-as.character(miga$Item)
waterfall(.data=miga,values =miga$Amount,labels =miga$Item,
          calc_total = TRUE, 
          total_rect_color = "steelblue2",
          total_axis_text = "summary income",
          rect_border = "white",
          fill_by_sign =TRUE)+
  coord_flip()
```

Income:Investment Income;Net Premium Income
Expenses:Decrease in Reserves;Administrative expenses

